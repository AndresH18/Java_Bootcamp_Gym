package com.javabootcamp.gym.services;

import com.javabootcamp.gym.data.dto.TrainerTrainingDto;
import com.javabootcamp.gym.data.dto.TrainingFilterDto;
import com.javabootcamp.gym.data.dto.UpdateTrainerDto;
import com.javabootcamp.gym.data.model.Trainer;
import com.javabootcamp.gym.data.model.TrainingType;
import com.javabootcamp.gym.data.model.User;
import com.javabootcamp.gym.data.viewmodels.TrainerRegistrationViewModel;
import com.javabootcamp.gym.helper.Result;
import com.javabootcamp.gym.services.delegate.repository.TrainerRepositoryDelegate;
import com.javabootcamp.gym.services.delegate.repository.TrainingRepositoryDelegate;
import com.javabootcamp.gym.services.delegate.repository.UserRepositoryDelegate;
import com.javabootcamp.gym.services.helper.ServiceHelper;
import com.javabootcamp.gym.services.user.ICreateService;
import com.javabootcamp.gym.services.user.UserService;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public final class TrainerService implements ICreateService<Trainer, TrainerRegistrationViewModel>, IUpdateService<UpdateTrainerDto> {
    private final Logger logger = LoggerFactory.getLogger(TrainerService.class);
    private final TrainerRepositoryDelegate trainerDelegate;
    private final TrainingRepositoryDelegate trainingDelegate;
    private final UserService userService;

    @Autowired
    public TrainerService(TrainerRepositoryDelegate trainerDelegate, TrainingRepositoryDelegate trainingDelegate, UserService userService) {
        this.trainerDelegate = trainerDelegate;
        this.trainingDelegate = trainingDelegate;
        this.userService = userService;
    }

    /**
     * Creates a new Trainer
     *
     * @param firstName          The User firstname
     * @param lastName           The User lastname
     * @param specializationName Name of the specialization. Must be a String value from {@link TrainingType}
     * @return A new instance of {@link Trainer} with the autogenerated properties populated,
     * or null if it couldn't be created.
     * @see User
     */
    @Nullable
    private Trainer create(@NotNull String firstName, @NotNull String lastName, String specializationName) {
        logger.trace("create: firstName='{}', lastName='{}', specializationName={}", firstName, lastName, specializationName);
        try {
            if (specializationName == null)
                return null;

            var specialization = TrainingType.valueOf(specializationName.toUpperCase());

            return trainerDelegate.saveWith(new Trainer(specialization),
                    () -> userService.createUser(firstName, lastName, User.Role.TRAINER));
        } catch (IllegalArgumentException e) {
            logger.warn("Cannot create Trainer. Specialization {} does not exist.", specializationName);
            throw e;
        }
    }

    @NotNull
    @Override
    public Result<Trainer, String> create(@NotNull TrainerRegistrationViewModel vm) {
        try {
            return Result.value(create(vm.getFirstName(), vm.getLastName(), vm.getSpecialization()));
        } catch (IllegalArgumentException e) {
            return Result.error("Specialization does not exist");
        } catch (Exception e) {
            logger.error("Failed to create trainer", e);
            return Result.error("There was an error creating the trainer");
        }
    }

    public Result<Trainer, Void> getByUsername(@NotNull String username) {
        logger.trace("getByUsername: username={}", username);
        try {
            var user = userService.get(username);

            return Result.value(user.map(User::getTrainer).orElse(null));
        } catch (Exception e) {
            logger.warn("Failed to get profile", e);
            return Result.error(null);
        }
    }

    @NotNull
    public Result<List<TrainerTrainingDto>, Void> getTrainings(@NotNull String username, @NotNull TrainingFilterDto dto) {
        try {
            var r = trainingDelegate.getTrainerTrainings(username, dto.periodFrom(), dto.periodTo(), dto.trainingTypeName(), dto.name());

            var l = r.stream()
                    .map(t -> new TrainerTrainingDto(
                            t.getName(),
                            t.getDate(),
                            t.getTrainingType().toString(),
                            t.getDuration(),
                            t.getTrainee().getUser().getUsername()));

            return Result.value(l.toList());
        } catch (Exception e) {
            logger.error("Error getting trainer trainings", e);
            return Result.error(null);
        }
    }

    public boolean update(@NotNull String username, @NotNull UpdateTrainerDto dto) {
        try {
//            var t = trainerRepository.findFirstByUserUsername(dto.username());
//            if (t.isEmpty())
//                return false;
//
//            var trainer = t.get();
//            trainer.getUser().setFirstName(dto.firstName());
//            trainer.getUser().setLastName(dto.lastName());
//            trainer.getUser().setActive(dto.isActive());

            var trainer = ServiceHelper.apply(username,
                    trainerDelegate::findByUsername,
                    UserRepositoryDelegate.updateUser(dto.firstName(), dto.lastName(), dto.isActive()),
                    Trainer::getUser);

            if (trainer == null)
                return false;

            TrainingType trainingType;
            if (dto.specialization() != null) {
                trainingType = TrainingType.valueOf(dto.specialization());
            } else {
                trainingType = TrainingType.byId(dto.specializationId());
            }
            trainer.setSpecialization(trainingType);

            trainerDelegate.save(trainer);

            return true;
        } catch (IllegalArgumentException e) {
            logger.info("Cannot update Trainer. Specialization does not exist.", e);
            return false;
        } catch (Exception e) {
            logger.error("Error updating trainer", e);
            return false;
        }
    }
}
