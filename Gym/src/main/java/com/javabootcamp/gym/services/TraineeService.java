package com.javabootcamp.gym.services;

import com.javabootcamp.gym.data.dto.TraineeTrainingDto;
import com.javabootcamp.gym.data.dto.TrainingFilterDto;
import com.javabootcamp.gym.data.dto.UpdateTraineeDto;
import com.javabootcamp.gym.data.model.Trainee;
import com.javabootcamp.gym.data.model.User;
import com.javabootcamp.gym.data.viewmodels.TraineeRegistrationViewModel;
import com.javabootcamp.gym.data.viewmodels.TrainerRegistrationViewModel;
import com.javabootcamp.gym.helper.Result;
import com.javabootcamp.gym.services.delegate.repository.TraineeRepositoryDelegate;
import com.javabootcamp.gym.services.delegate.repository.TrainingRepositoryDelegate;
import com.javabootcamp.gym.services.delegate.repository.UserRepositoryDelegate;
import com.javabootcamp.gym.services.helper.ServiceHelper;
import com.javabootcamp.gym.services.user.ICreateService;
import com.javabootcamp.gym.services.user.UserService;
import jakarta.transaction.Transactional;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class TraineeService implements ICreateService<Trainee, TraineeRegistrationViewModel>, IUpdateService<UpdateTraineeDto> {
    private final Logger logger = LoggerFactory.getLogger(TraineeService.class);
    private final TraineeRepositoryDelegate traineeDelegate;
    private final TrainingRepositoryDelegate trainingDelegate;
    private final UserService userService;

    @Autowired
    public TraineeService(TraineeRepositoryDelegate traineeDelegate, TrainingRepositoryDelegate trainingDelegate, UserService userService) {
        this.traineeDelegate = traineeDelegate;
        this.trainingDelegate = trainingDelegate;
        this.userService = userService;
    }

    /**
     * Create a new User and a Trainee with the User id
     *
     * @param firstName   The User firstname
     * @param lastName    The User lastname
     * @param dateOfBirth The Trainee date of birth
     * @param address     The Trainee address
     * @return A new instance of {@link Trainee} with autogenerated properties populated, including the userId, or null
     * if the {@code dateOfBirth} is incorrect or there was a problem when writing to the datasource
     * @see User
     */
    @Nullable
    private Trainee create(@NotNull String firstName, @NotNull String lastName, @NotNull LocalDate dateOfBirth, @NotNull String address) {
        logger.trace("create: firstName='{}', lastName={}, dateOfBirth={}, address='{}'", firstName, lastName, dateOfBirth, address);

        if (!ServiceHelper.isValidDate(dateOfBirth)) return null;

        return traineeDelegate.saveWith(new Trainee(dateOfBirth, address),
                () -> userService.createUser(firstName, lastName, User.Role.TRAINEE));
    }

    public Result<Trainee, String> create(TraineeRegistrationViewModel vm) {
        try {
            return Result.value(create(vm.getFirstName(), vm.getLastName(), vm.getDateOfBirth(), vm.getAddress()));
        } catch (Exception e) {
            logger.error("Failed to create trainee", e);
            return Result.error("There was an error creating the trainee");
        }
    }

    public Result<Trainee, Void> getByUsername(@NotNull String username) {
        logger.trace("getByUsername: username={}", username);
        try {
            var user = userService.get(username);

            return Result.value(user.map(User::getTrainee).orElse(null));
        } catch (Exception e) {
            logger.warn("Failed to get profile", e);
            return Result.error(null);
        }
    }

    @NotNull
    public Result<List<TraineeTrainingDto>, Void> getTrainings(@NotNull String username, @NotNull TrainingFilterDto dto) {
        try {
            var r = trainingDelegate.getTraineeTrainings(username, dto.periodFrom(), dto.periodTo(), dto.trainingTypeName(), dto.name());

            var l = r.stream()
                    .map(t -> new TraineeTrainingDto(
                            t.getName(),
                            t.getDate(),
                            t.getTrainingType().toString(),
                            t.getDuration(),
                            t.getTrainer().getUser().getUsername()));

            return Result.value(l.toList());
        } catch (Exception e) {
            logger.error("Error getting trainee trainings", e);
            return Result.error(null);
        }
    }

    @Override
    public boolean update(@NotNull String username, @NotNull UpdateTraineeDto dto) {
        try {
/*            var t = traineeRepository.findFirstByUserUsername(dto.username());
            if (t.isEmpty())
                return false;

            var trainee = t.get();
            trainee.getUser().setFirstName(dto.firstName());
            trainee.getUser().setLastName(dto.lastName());
            trainee.getUser().setActive(dto.isActive());*/
            var trainee =
                    ServiceHelper.apply(username,
                            traineeDelegate::findByUsername,
                            UserRepositoryDelegate.updateUser(dto.firstName(), dto.lastName(), dto.isActive()),
                            Trainee::getUser);

            if (trainee == null)
                return false;

            if (dto.dateOfBirth() != null)
                trainee.setDateOfBirth(dto.dateOfBirth());

            if (dto.address() != null)
                trainee.setAddress(dto.address());

            traineeDelegate.save(trainee);

            return true;
        } catch (Exception e) {
            logger.error("Error updating trainee", e);
            return false;
        }
    }

    @NotNull
    public Optional<Boolean> delete(@NotNull String username) {
        try {
            var t = traineeDelegate.findByUsername(username);

            if (t.isEmpty())
                return Optional.empty();

            traineeDelegate.delete(t.get());
            return Optional.of(true);
        } catch (Exception e) {
            logger.error("Error deleting trainee", e);
            return Optional.of(false);
        }
    }
}
